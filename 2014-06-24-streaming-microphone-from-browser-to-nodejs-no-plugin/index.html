<html class="min-h-full h-full w-full dark" lang="en"><head><title>Gabriel Poça | Tutorial: HTML Audio Capture streaming to Node.js (no browser extensions)</title><meta content="Gabriel Poça | Tutorial: HTML Audio Capture streaming to Node.js (no browser extensions)" name="title"><meta content="Tutorial: HTML Audio Capture streaming to Node.js (no browser extensions)" name="description"><meta content="website" property="og:type"><meta content="https://gabrielpoca.com/2014-06-24-streaming-microphone-from-browser-to-nodejs-no-plugin/index.html" property="og:url"><meta content="Gabriel Poça | Tutorial: HTML Audio Capture streaming to Node.js (no browser extensions)" property="og:title"><meta content="Tutorial: HTML Audio Capture streaming to Node.js (no browser extensions)" property="og:description"><meta content="https://gabrielpoca.com/https://gabrielpoca.com/2014-06-24-streaming-microphone-from-browser-to-nodejs-no-plugin/seo.png" property="og:image"><meta content="summary_large_image" property="twitter:card"><meta content="https://gabrielpoca.com/2014-06-24-streaming-microphone-from-browser-to-nodejs-no-plugin/index.html" property="twitter:url"><meta content="Gabriel Poça | Tutorial: HTML Audio Capture streaming to Node.js (no browser extensions)" property="twitter:title"><meta content="Tutorial: HTML Audio Capture streaming to Node.js (no browser extensions)" property="twitter:description"><meta content="https://gabrielpoca.com/https://gabrielpoca.com/2014-06-24-streaming-microphone-from-browser-to-nodejs-no-plugin/seo.png" property="twitter:image"><link href="/icon.png" rel="icon" type="image/png"><meta content="text/html; charset=utf-8" http-equiv="Content-Type"><meta content="width=device-width, initial-scale=1.0" name="viewport"><link rel="stylesheet"  href="/global-4o-YP5JaY5pUORpLfbaOEw==.css" />
<link rel="stylesheet"  href="/site-mEL6LQbJJlCImN4ZkVYbKg==.css" />
</head><body class="overscroll-none antialiased font-sans min-h-full h-full overflow-x-hidden w-full bg-black-light text-my-white text-base"><header class="flex justify-between px-4 md_px-8 items-center absolute top-0 left-0 w-full z-20 text-my-white"><a href="/" class="flex items-center -mt-1"><img src="/_includes/me small-109857605-256w.png" srcset="/_includes/me small-109857605-64w.png 64w, /_includes/me small-109857605-128w.png 128w, /_includes/me small-109857605-192w.png 192w, /_includes/me small-109857605-256w.png 256w" class="w-8 mr-3"/><span class="invisible sm_visible text-sm font-bold">Gabriel Poça</span></a><nav class="flex justify-end space-x-2 sm_space-x-5 uppercase tracking-widest h-16 items-center z-10 relative text-xs font-bold sm_text-sm"><a href="/" class="font-normal hidden md_block">Home</a><a href="/books" class="font-normal">Reading</a><a href="/music" class="font-normal">Music</a><a href="/now" class="font-normal">Now</a><a href="/about" class="font-normal">About</a></nav></header><article><div class="text-center relative flex items-center justify-center" style="height:85vh"><h1 class="mb-8 text-4xl font-bold z-20 relative px-8 max-w-screen-lg sm_text-5xl">Tutorial: HTML Audio Capture streaming to Node.js (no browser extensions)</h1></div><div class="container pb-32 pt-12"><h2 class="mb-6 section-heading">Blog Post</h2><div class="prose max-w-none prose-lg e-content"><p>I’m taking the time to write the tutorial I wish I had some months ago. My task was to set up some user voice recording mechanism in the browser. It should record for about one hour, non-stop, saving to a server. The idea was to use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getUserMedia" title="">getUserMedia()</a> API. No browser extensions should be used.</p><p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getUserMedia" title="">getUserMedia()</a> API allows web apps to request access to a media device such as a camera or microphone. It yields raw PCM data.</p><h2>Round One</h2><p>We approached the task looking for the smallest change that solved the problem. We did it using <a href="https://github.com/muaz-khan/WebRTC-Experiment/tree/master/RecordRTC" title="">RecordRTC</a>. It records the microphone in the browser. When finished, we can upload it to a server through a normal request. Let me show you how it works.</p><p>Add the RecordRTC library.</p><pre><code class="html">&lt;script src=&quot;//www.WebRTC-Experiment.com/RecordRTC.js&quot;&gt;&lt;/script&gt;</code></pre><p>Request access to the microphone.</p><pre><code class="javascript">var session = {
  audio: true,
  video: false,
};
var recordRTC = null;
navigator.getUserMedia(
  session,
  function (mediaStream) {
    recordRTC = RecordRTC(MediaStream);
    recordRTC.startRecording();
  },
  onError
);</code></pre><p>When finished recording, stop and upload to a server.</p><pre><code class="javascript">recordRTC.stopRecording(function (audioURL) {
  var formData = new FormData();
  formData.append(&quot;edition[audio]&quot;, recordRTC.getBlob());
  $.ajax({
    type: &quot;POST&quot;,
    url: &quot;some/path&quot;,
    data: formData,
    contentType: false,
    cache: false,
    processData: false,
  });
});</code></pre><p>The code works, but you shouldn’t write code like this, it’s just an example.</p><h3>Drawbacks</h3><p>Audio is recorded in wav format. An one hour recording, with one channel, can take around 500mb. This is a problem for the browser limited memory. Also the upload would take ages! It wasn’t working.</p><h2>Round Two</h2><p>After reading the source code from <a href="https://github.com/muaz-khan/WebRTC-Experiment/tree/master/RecordRTC" title="">RecordRTC</a> (ugly) and <a href="https://github.com/mattdiamond/Recorderjs" title="">RecorderJS</a>, I realised that using a <a href="https://developer.mozilla.org/en-US/docs/Web/API/ScriptProcessorNode">ScriptProcessorNode</a> I can write JavaScript to send data chunks (audio samples) from the microphone to a server.</p><p>Turns out it’s harder than it seems, mostly because of the lack of information. There are a couple of related Stack Overflow answers (I will add them in the end), but I won’t bother you with this. Let’s move on to the code.</p><h3>Reading data from the microphone</h3><p>First request microphone access.</p><pre><code class="javascript">var session = {
  audio: true,
  video: false,
};
var recordRTC = null;
navigator.getUserMedia(session, initializeRecorder, onError);</code></pre><p>Having the microphone stream you can use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioContext" title="">AudioContext</a> interface to make the audio (PCM data) go through different processing nodes before reaching its destination. There are nodes for gain, compressor, panner, and much more. We are going to write a custom node, so we can access the audio samples. For that we add a <a href="https://developer.mozilla.org/en-US/docs/Web/API/ScriptProcessorNode">ScriptProcessorNode</a>.</p><pre><code class="javascript">function initializeRecorder(stream) {
  var audioContext = window.AudioContext;
  var context = new audioContext();
  var audioInput = context.createMediaStreamSource(stream);
  var bufferSize = 2048;
  // create a javascript node
  var recorder = context.createJavaScriptNode(bufferSize, 1, 1);
  // specify the processing function
  recorder.onaudioprocess = recorderProcess;
  // connect stream to our recorder
  audioInput.connect(recorder);
  // connect our recorder to the previous destination
  recorder.connect(context.destination);
}</code></pre><p>After this, every audio sample will go through the <code class="inline">recorderProcess</code> function.</p><pre><code class="javascript">function recorderProcess(e) {
  var left = e.inputBuffer.getChannelData(0);
}</code></pre><p>We have now PCM data samples from the left channel. Since we are recording in mono we only need the left channel. Now moving on to streaming these chunks to the server.</p><h3>Communication</h3><p>We are using WebSockets to send the samples to the server. The server is going to be written in Node.js.</p><p>I started with <a href="http://socket.io/" title="">Socket.IO</a>. When things didn’t work I realised Socket.IO doesn’t support binary communication (in fact, it does now, I made this before it did). <a href="http://binaryjs.com/" title="">BinaryJS</a> does support binary communication, so I moved to it.</p><p><strong>Setup BinaryJS</strong></p><p>First add the BinaryJS library.</p><pre><code class="html">&lt;script src=&quot;http://cdn.binaryjs.com/0/binary.js&quot;&gt;&lt;/script&gt;</code></pre><p>Now start a connection.</p><pre><code class="javascript">var client = new BinaryClient(&quot;ws://localhost:9001&quot;);</code></pre><p>When ready, create a write stream.</p><pre><code class="javascript">client.on(&#39;open&#39;, function() {
  // for the sake of this example let&#39;s put the stream in the window
  window.Stream = client.createStream();
}</code></pre><p>Going back to our custom node let’s send the audio to the stream.</p><pre><code class="javascript">function recorderProcess(e) {
  var left = e.inputBuffer.getChannelData(0);
  window.Stream.write(left);
}</code></pre><p>Everything should be ready on the client side now. Our <code class="inline">recorderProcess</code> function is called for each audio chunk, and each is sent to the server.</p><p>But we aren’t ready yet! There is one important step missing. WebAudio samples are in Float32. If you choose to send them like this you need to know that <a href="https://developer.mozilla.org/en-US/docs/Web/API/Uint16Array">endianness does matter</a>. I chose to convert them to 16 bit signed integers:</p><pre><code class="javascript">function convertFloat32ToInt16(buffer) {
  l = buffer.length;
  buf = new Int16Array(l);
  while (l--) {
    buf[l] = Math.min(1, buffer[l]) * 0x7fff;
  }
  return buf.buffer;
}

function recorderProcess(e) {
  var left = e.inputBuffer.getChannelData(0);
  window.Stream.write(convertFloat32ToInt16(left));
}</code></pre><p>We are now done with the client code. Moving on to the server.</p><h3>Setting up a server</h3><p>I’m not getting into much detail on the server, I’m just going to show how to put these chunks in a playable media file. I’m assuming you already have <a href="http://nodejs.org/" title="">Node.js</a> installed.</p><p>We need <a href="http://binaryjs.com/" title="">BinaryJS</a>, and <a href="https://github.com/TooTallNate/node-wav" title="">node-wav</a> on the server. The first is for communication, and the second accepts raw audio data and outputs a WAV file with a valid WAVE header.</p><pre><code class="bash">npm init
npm install binaryjs
npm install wav</code></pre><p>Now create the <code class="inline">index.js</code> file and start the BinaryJS server.</p><pre><code class="javascript">var binaryServer = require(&#39;binaryjs&#39;).BinaryServer;
var wav = require(&#39;wav&#39;);

var server = binaryServer({port: 9001});

server.on(&#39;connection&#39;, function(client) {
  ...
});</code></pre><p>Inside the <code class="inline">server.on(&#39;connection&#39;, function)</code> callback node-wav is going to help pipe the stream into a file.</p><pre><code class="javascript">var fileWriter = null;

client.on(&quot;stream&quot;, function (stream, meta) {
  var fileWriter = new wav.FileWriter(&quot;demo.wav&quot;, {
    channels: 1,
    sampleRate: 48000,
    bitDepth: 16,
  });
  stream.pipe(fileWriter);
  stream.on(&quot;end&quot;, function () {
    fileWriter.end();
  });
});

client.on(&quot;close&quot;, function () {
  if (fileWriter != null) {
    fileWriter.end();
  }
});</code></pre><p>For a better understanding you should read <a href="https://github.com/TooTallNate/node-wav" title="">node-wav</a> document. In fact, you should read the source code since there isn’t much documentation. Simply put, <code class="inline">wav.FileWriter</code> accepts a pcm stream and sends it to a media file, setting the right header for the file.</p><p>Notice the settings for <code class="inline">wav.FileWriter</code> are hardcoded, but they can be sent through the stream. Parameters like sample rate change for each client.</p><h2>Setup complete</h2><p>You are ready to start recording. There is still a long way to go from here. You should probably support restoring the connection if it goes down, and append the audio to the same media.</p><h2>Wrap it up</h2><p>You can now start from here and build your own platform with audio recording. Maybe a personal note-taking platform.</p><p>This solution allows you to record the microphone while not worrying about upload time and audio loss. The full source code is <a href="https://github.com/gabrielpoca/browser-pcm-stream">here</a>. Feel free to leave any questions and comments.</p><h3>StackOverflow related answers</h3><ul><li><a href="http://stackoverflow.com/questions/21079972/sound-card-detection-for-web/21080953#21080953">Sound card detection for web</a></li><li><a href="http://stackoverflow.com/questions/20876152/playing-pcm-stream-from-web-audio-api-on-node-js">Playing PCM stream from Web Audio API on Node.js</a></li><li><a href="http://stackoverflow.com/questions/20850396/stream-recorded-audio-from-browser-to-server">Stream recorded audio from browser to server</a></li></ul></div></div></article><div class="h-4 bg-fuchsia-darker w-full"></div><div class="h-4 bg-fuchsia-dark w-full"></div><footer class="relative flex footer-bg-color"><img src="/_includes/footer/bg-27398931-11568w.jpg" srcset="/_includes/footer/bg-27398931-2892w.jpg 2892w, /_includes/footer/bg-27398931-5784w.jpg 5784w, /_includes/footer/bg-27398931-8676w.jpg 8676w, /_includes/footer/bg-27398931-11568w.jpg 11568w" class="absolute bottom-0 left-0 h-full object-left-bottom w-full object-cover xl_object-contain"/><div class="relative container pt-28 pb-52 sm_pt-40 sm_pb-60"><p class="font-bold mb-2">Hey! <br /> Thanks for stopping by.</p><p class="flex-grow mb-2">And feel free to reach out to me on <a href="https://twitter.com/gabrielgpoca" rel="noopener noreferrer" target="_blank" class="underline underline-current-color text-hover-none">Twitter</a> or <a class="underline underline-current-color text-hover-none" href="mailto:mail@gabrielpoca.com">e-mail</a>.<br />I'm always available to listen, talk, share, or brainstorm.</p><p class="flex-grow mb-2">For more information see the <a href="/about" class="underline underline-current-color text-hover-none">about page</a>.</p><p class="flex-grow">You can subscribe to this blog using <a href="/rss.xml" class="underline underline-current-color text-hover-none">RSS</a>.</p></div></footer><script data-goatcounter="https://gabrielpoca.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script></body></html>